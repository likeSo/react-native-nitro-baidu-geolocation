///
/// JGetLocationOptions.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include <fbjni/fbjni.h>
#include "GetLocationOptions.hpp"

#include "CoordinateType.hpp"
#include "JCoordinateType.hpp"
#include "JLocationDesiredAccuracy.hpp"
#include "LocationDesiredAccuracy.hpp"
#include <optional>
#include <string>

namespace margelo::nitro::nitrobaidugeolocation {

  using namespace facebook;

  /**
   * The C++ JNI bridge between the C++ struct "GetLocationOptions" and the the Kotlin data class "GetLocationOptions".
   */
  struct JGetLocationOptions final: public jni::JavaClass<JGetLocationOptions> {
  public:
    static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/nitrobaidugeolocation/GetLocationOptions;";

  public:
    /**
     * Convert this Java/Kotlin-based struct to the C++ struct GetLocationOptions by copying all values to C++.
     */
    [[maybe_unused]]
    [[nodiscard]]
    GetLocationOptions toCpp() const {
      static const auto clazz = javaClassStatic();
      static const auto fieldDesiredAccuracy = clazz->getField<JLocationDesiredAccuracy>("desiredAccuracy");
      jni::local_ref<JLocationDesiredAccuracy> desiredAccuracy = this->getFieldValue(fieldDesiredAccuracy);
      static const auto fieldAllowsBackgroundLocationUpdates = clazz->getField<jni::JBoolean>("allowsBackgroundLocationUpdates");
      jni::local_ref<jni::JBoolean> allowsBackgroundLocationUpdates = this->getFieldValue(fieldAllowsBackgroundLocationUpdates);
      static const auto fieldCoordinateType = clazz->getField<JCoordinateType>("coordinateType");
      jni::local_ref<JCoordinateType> coordinateType = this->getFieldValue(fieldCoordinateType);
      static const auto fieldLocatingWithReGeocode = clazz->getField<jni::JBoolean>("locatingWithReGeocode");
      jni::local_ref<jni::JBoolean> locatingWithReGeocode = this->getFieldValue(fieldLocatingWithReGeocode);
      static const auto fieldUserId = clazz->getField<jni::JString>("userId");
      jni::local_ref<jni::JString> userId = this->getFieldValue(fieldUserId);
      return GetLocationOptions(
        desiredAccuracy != nullptr ? std::make_optional(desiredAccuracy->toCpp()) : std::nullopt,
        allowsBackgroundLocationUpdates != nullptr ? std::make_optional(static_cast<bool>(allowsBackgroundLocationUpdates->value())) : std::nullopt,
        coordinateType != nullptr ? std::make_optional(coordinateType->toCpp()) : std::nullopt,
        locatingWithReGeocode != nullptr ? std::make_optional(static_cast<bool>(locatingWithReGeocode->value())) : std::nullopt,
        userId != nullptr ? std::make_optional(userId->toStdString()) : std::nullopt
      );
    }

  public:
    /**
     * Create a Java/Kotlin-based struct by copying all values from the given C++ struct to Java.
     */
    [[maybe_unused]]
    static jni::local_ref<JGetLocationOptions::javaobject> fromCpp(const GetLocationOptions& value) {
      return newInstance(
        value.desiredAccuracy.has_value() ? JLocationDesiredAccuracy::fromCpp(value.desiredAccuracy.value()) : nullptr,
        value.allowsBackgroundLocationUpdates.has_value() ? jni::JBoolean::valueOf(value.allowsBackgroundLocationUpdates.value()) : nullptr,
        value.coordinateType.has_value() ? JCoordinateType::fromCpp(value.coordinateType.value()) : nullptr,
        value.locatingWithReGeocode.has_value() ? jni::JBoolean::valueOf(value.locatingWithReGeocode.value()) : nullptr,
        value.userId.has_value() ? jni::make_jstring(value.userId.value()) : nullptr
      );
    }
  };

} // namespace margelo::nitro::nitrobaidugeolocation
